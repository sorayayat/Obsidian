
---
### 제 1정규화 (1NF)


| no  | 이름  | 구매 목록 |
| :-: | :-: | :---: |
|  1  | 로사  |  토마토  |
|  2  | 로이  |  감자   |
|  3  | 냐옹이 |  연어   |
|  4  | 피카츄 |  삼겹살  |

- 다음과 같은 테이블이 존재하는데 피카츄가 상추를 추가 구매 한다면?

⬇️

| no  | 이름  |  구매 목록  |
| :-: | :-: | :-----: |
|  1  | 로사  |   토마토   |
|  2  | 로이  |   감자    |
|  3  | 냐옹이 |   연어    |
|  4  | 피카츄 | 삼겹살, 상추 |
>이런 방법으로 저장한다면 나중에 다양한 문제가 발생한다.
> (상추를 구매한 사람을 찾으려면 LIKE절 사용 등 쿼리 복잡해진다.)

| no  | 이름  | 구매 목록 |
| :-: | :-: | :---: |
|  1  | 로사  |  토마토  |
|  2  | 로이  |  감자   |
|  3  | 냐옹이 |  연어   |
|  4  | 피카츄 |  삼겹살  |
|  4  | 피카츄 |  상추   |

1NF 정규화 (도메인이 원자값) -> 한칸에는 하나의 데이터만 존재

---

### 제 2정규화 (2NF)

| no  | 이름  | 구매 목록 | 가격   | 결제 여부 |
| --- | --- | ----- | ---- | ----- |
| 1   | 로사  | 토마토   | 1000 | 0     |
| 2   | 로이  | 감자    | 1500 | 1     |
| 3   | 냐옹이 | 연어    | 3000 | 1     |
| 4   | 피카츄 | 삼겹살   | 3500 | 0     |
| 2   | 로이  | 토마토   | 1000 | 1     |
> 만약에 토마토 가격이 오른다면.....?
> 토마토를 구매한 사람이 수백 수천명이면 하나씩 찾아서 바꿔야한다.

⬇️

| no  | 이름  | 구매 목록 | 결제 여부 |
| --- | --- | ----- | ----- |
| 1   | 로사  | 토마토   | 0     |
| 2   | 로이  | 감자    | 1     |
| 3   | 냐옹이 | 연어    | 1     |
| 4   | 피카츄 | 삼겹살   | 0     |
| 2   | 로이  | 토마토   | 1     |

| 품목  | 가격   |
| --- | ---- |
| 토마토 | 1000 |
| 감자  | 1500 |
| 연어  | 3000 |
| 삼겹살 | 3500 |


> 따로 테이블로 뺍시다.

2NF 정규화 (부분적 종속 제거) -> 주제와 관련 없는 테이블을 따로 빼서 관리

장점 : 수정이 쉽다
단점 : 회원 테이블만 봐서는 가격이 얼마인지 몰라 찾아가야한다.

partial dependency를 제거한 테이블이라고도 한다.
~~(대충 어려운 말)~~


primary key가 없다면 ?!?!

복합키를 사용해서 사용가능하다.
Composite primary key

| no  |  이름  | 구매 목록 | 가격 | 결제 여부 |
|:---:|:------:|:---------:|:----:|:---------:|
|  1  |  로사  |  토마토   | 1000 |     0     |
|  2  |  로이  |   감자    | 1500 |     1     |
|  3  | 냐옹이 |   연어    | 3000 |     1     |
|  4  | 피카츄 |  삼겹살   | 3500 |     0     |
|  2  |  로이  |  토마토   | 1000 |     1     |
 no + 구매 목록 = Composite primary key

근데 여기서 구매 목록에 가격이 종속 되어있다.
이걸 partial dependency가 있다. 라고 한다

그래서 이걸 다른곳 테이블로 빼면 제 2 정규형 테이블이 된다.

--- 

### 제 3정규화 (3NF)


| 품목  |  가격  | 판매자 | 원산지 |
| :-: | :--: | :-: | :-: |
| 토마토 | 1000 | 티파니 | 청주  |
| 감자  | 1500 | 톰  | 평창  |
| 연어  | 3000 | 라이언 | 이천  |
| 삼겹살 | 3500 | 리사  | 제주  |
| 대파  | 2000 | 티파니 | 청주  |
- 제 2 정규화된 테이블

판매자에게 원산지가 종속되어 있다.

이걸 따로 빼서 테이블로 만들어 준다.

 ⬇️

| 판매자 | 원산지 |
| :-: | :-: |
| 티파니 | 청주  |
| 톰  | 평창  |
| 라이언 | 이천  |
| 리사  | 제주  |

만약에 티파니가  '서울'로 옮긴다면?
수정이 쉬워진다.

> 2 정규화된 테이블을 쪼개어 테이블을 만드는 것

문제는 일반 테이블을 보고 원산지를 알수 없어서 찾아와야하는 복잡함 발생

이렇게 쪼개 가는 것을 정규화

정규화를 했는데 성능 저하가 발생 한다면
#### 반정규화 고려